-ifdef(TEST).

% Machine behaviour:

% start_transaction:
%     cleanup any old transations for the pid
%     add the pid to transactions with unique transaction ID
%     monitor the pid
%     return the unique transaction ID

% %% Create a transaction
% [] -> Pid -> [{Pid, TID0, []}]
% %% Replace existing transaction for the process
% [{Pid,TID1, []}] -> Pid -> [{Pid,TID2, []}]
% %% Clean all locks when replacing a transaction
% [{Pid,TID1, [L1, L2]}] -> Pid -> [{Pid,TID2, []}]
% %% Keep other process transaction locks
% [{Pid1,TID1, [...]}] -> Pid -> [{Pid1,TID1, [...]},{Pid,TID2, []}]

start_transaction_test() ->
    InitState = #state{},
    Source = self(),
    {#state{transactions = #{Source := Tid}, last_transaction_id = Tid},
     [{monitor, process, Source}],
     {ok, Tid}} = ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState).

start_transaction_cleanup_test() ->
    Source = self(),
    InitState = #state{transactions = #{Source => 1}, last_transaction_id = 1},
    {#state{transactions = #{Source := Tid}, last_transaction_id = Tid},
     [{monitor, process, Source}],
     {ok, Tid}} = ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    true = Tid =/= 1.

start_transaction_cleanup_locks_test() ->
    Source = self(),
    Tid = 1,
    Source1 = spawn(fun() -> ok end),
    Source2 = spawn(fun() -> ok end),
    Tid1 = 2,
    Tid2 = 3,
    LastTid = 3,
    InitState = #state{transactions = #{Source => Tid,
                                        Source1 => Tid1,
                                        Source2 => Tid2},
                       last_transaction_id = LastTid,
                       write_locks = #{writelock => Tid, writelock_1 => Tid1},
                       read_locks = #{readlock => [Tid],
                                      readlock_1 => [Tid, Tid1],
                                      readlock_2 => [Tid2]}},
    {#state{transactions = #{Source := NewTid, Source1 := Tid1, Source2 := Tid2},
            last_transaction_id = NewTid,
            write_locks = WLocks,
            read_locks = RLocks},
     [{monitor, process, Source}],
     {ok, NewTid}} = ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    true = Tid =/= NewTid,
    WLocks = #{writelock_1 => Tid1},
    RLocks = #{readlock_1 => [Tid1], readlock_2 => [Tid2]}.

% rollback:
%     fail if transaction does not match the pid
%     cleanup locks for transaction
%     cleanup transaction for the pid
%     demonitor the pid
%     return ok

% %% Error if no transaction
% [] -> TID, Pid -> error: no transaction
% %% Error if wrong transaction
% [{Pid, TID1, [...]}] -> TID, Pid -> error: wrong transaction
% %% Cleanup transaction
% [{Pid, TID, [...]}] -> TID, Pid -> []

rollback_no_transaction_error_test() ->
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {rollback, Tid, Source, []}, [], InitState).

rollback_wrong_transaction_error_test() ->
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {rollback, Tid, Source, []}, [], InitState).

rollback_cleanup_test() ->
    Source = self(),
    InitState = #state{},
    {State = #state{last_transaction_id = LastTid}, [{monitor, process, Source}], {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, [{demonitor, process, Source}], _} =
        ramnesia_machine:apply(none, {rollback, Tid, Source, []}, [], State),
    Expected = #state{last_transaction_id = LastTid},
    Expected = State1.

rollback_cleanup_locks_test() ->
    Source = self(),
    Tid = 1,
    Source1 = spawn(fun() -> ok end),
    Tid1 = 2,
    Source2 = spawn(fun() -> ok end),
    Tid2 = 3,
    LastTid = 3,
    InitState = #state{transactions = #{Source => Tid,
                                        Source1 => Tid1,
                                        Source2 => Tid2},
                       last_transaction_id = LastTid,
                       write_locks = #{writelock => Tid,
                                       writelock_1 => Tid1},
                       read_locks = #{readlock => [Tid],
                                      readlock_1 => [Tid, Tid1],
                                      readlock_2 => [Tid2]}},
    {State1, [{demonitor, process, Source}], _} =
        ramnesia_machine:apply(none, {rollback, Tid, Source, []}, [], InitState),
    Expected = #state{last_transaction_id = LastTid,
                      transactions = #{Source1 => Tid1, Source2 => Tid2},
                      write_locks = #{writelock_1 => Tid1},
                      read_locks = #{readlock_1 => [Tid1], readlock_2 => [Tid2]}},
    Expected = State1,
    {State2, [{demonitor, process, Source1}], _} =
        ramnesia_machine:apply(none, {rollback, Tid1, Source1, []}, [], State1),
    {State3, [{demonitor, process, Source2}], _} =
        ramnesia_machine:apply(none, {rollback, Tid2, Source2, []}, [], State2),
    State3 = #state{last_transaction_id = LastTid}.


% commit:
%     fail if transaction does not match the pid
%     do same as rollback

commit_no_transaction_error_test() ->
    mnesia:start(),
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {commit, Tid, Source, [[], [], []]}, [], InitState).

commit_wrong_transaction_error_test() ->
    mnesia:start(),
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {commit, Tid, Source, [[], [], []]}, [], InitState).

commit_cleanup_test() ->
    mnesia:start(),
    Source = self(),
    InitState = #state{},
    {State = #state{last_transaction_id = LastTid}, [{monitor, process, Source}], {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, [], _} =
        ramnesia_machine:apply(none, {commit, Tid, Source, [[], [], []]}, [], State),
    Expected = #state{last_transaction_id = LastTid,
                      transactions = #{},
                      committed_transactions = #{Tid => Source}},
    Expected = State1,
    {State2, [{demonitor, process, Source}]} =
        ramnesia_machine:apply(none, {finish, Tid, Source}, [], State1),
    Expected1 = #state{last_transaction_id = LastTid},
    Expected1 = State2.

commit_cleanup_locks_test() ->
    mnesia:start(),
    Source = self(),
    Tid = 1,
    Source1 = spawn(fun() -> ok end),
    Tid1 = 2,
    Source2 = spawn(fun() -> ok end),
    Tid2 = 3,
    LastTid = 3,
    InitState = #state{transactions = #{Source => Tid,
                                        Source1 => Tid1,
                                        Source2 => Tid2},
                       last_transaction_id = LastTid,
                       write_locks = #{writelock => Tid,
                                       writelock_1 => Tid1},
                       read_locks = #{readlock => [Tid],
                                      readlock_1 => [Tid, Tid1],
                                      readlock_2 => [Tid2]}},
    {State1, [{demonitor, process, Source}]} =
        ramnesia_machine:apply(none, {finish, Tid, Source}, [],
            element(1, ramnesia_machine:apply(none, {commit, Tid, Source, [[], [], []]}, [], InitState))),

    Expected = #state{last_transaction_id = LastTid,
                      transactions = #{Source1 => Tid1, Source2 => Tid2},
                      write_locks = #{writelock_1 => Tid1},
                      read_locks = #{readlock_1 => [Tid1], readlock_2 => [Tid2]}},
    Expected = State1,
    {State2, _, _} =
        ramnesia_machine:apply(none, {commit, Tid1, Source1, [[], [], []]}, [], State1),
    {State3, _, _} =
        ramnesia_machine:apply(none, {commit, Tid2, Source2, [[], [], []]}, [], State2),
    State3 = #state{last_transaction_id = LastTid,
                    transactions = #{},
                    committed_transactions = #{Tid1 => Source1, Tid2 => Source2}}.

commit_write_test() ->
    mnesia:start(),
    mnesia:create_table(foo, []),
    %% To delete
    mnesia:dirty_write({foo, to_delete, val}),
    %% To delete during delete_object
    mnesia:dirty_write({foo, to_delete_object, val}),
    %% To skip during delete_object
    mnesia:dirty_write({foo, to_not_delete_object, not_val}),
    %% To reqrite during write
    mnesia:dirty_write({foo, to_rewrite, val}),
    Source = self(),
    InitState = #state{},
    {State1, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    %% Writes are of {Table, Record, LockKind} format
    Writes = [{foo, {foo, to_rewrite, other_val}, write},
              {foo, {foo, to_write, val}, write}],
    %% Deletes are of {Table, Key, LockKind} format
    Deletes = [{foo, bar, write},
               {foo, to_delete, write}],
    DeletesObject = [{foo, {foo, to_delete_object, val}, write},
                     {foo, {foo, to_not_delete_object, val}, write}],
    Expected = lists:usort([{foo, to_rewrite, other_val},
                            {foo, to_write, val},
                            {foo, to_not_delete_object, not_val}]),
    {_State2, _, _} =
        ramnesia_machine:apply(none, {commit, Tid, Source, [Writes, Deletes, DeletesObject]}, [], State1),
    Table = lists:usort(ets:tab2list(foo)),
    Expected = Table.

% lock:
%     fail if no transaction
%     if write-locked:
%         fail
%     if read-locked;
%         if new lock is write:
%             fail
%     add new lock
%     return ok

lock_no_transaction_error_test() ->
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{table, foo}, read]}, [], InitState).

lock_wrong_transaction_error_test() ->
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{table, foo}, read]}, [], InitState).

lock_aquire_read_test() ->
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks, write_locks = WLocks}, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{table, foo}, read]}, [], State),
    ExpectedW = #{},
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedW = WLocks,
    ExpectedR = RLocks.

lock_aquire_read_multiple_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2 = #state{read_locks = RLocks, write_locks = WLocks}, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{table, foo}, read]}, [], State1),
    ExpectedW = #{},
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedW = WLocks,
    ExpectedR = RLocks,
    {#state{read_locks = RLocks1, write_locks = WLocks1}, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, read]}, [], State2),
    ExpectedW1 = #{},
    ExpectedR1 = #{{table, foo} => [Tid1, Tid]},
    ExpectedW1 = WLocks1,
    ExpectedR1 = RLocks1.

lock_aquire_write_test() ->
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks, write_locks = WLocks}, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{table, foo}, write]}, [], State),
    WLocks = #{{table, foo} => Tid},
    RLocks = #{}.

lock_read_blocked_by_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{foo, bar}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{foo, bar}, read]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid),

    %% Locking transaction finish unlocks the locked
    {State4, [{send_msg, Source, {ramnesia_unlock, Tid}},
              {demonitor, process, Source1}], {ok, ok}} =
        ramnesia_machine:apply(none, {rollback, Tid1, Source1, []}, [], State3),
    TLGraph1 = State4#state.transaction_locks,
    error = simple_dgraph:vertex_label(TLGraph1, Tid1),
    [] = simple_dgraph:in_edges(TLGraph1, Tid).


lock_read_blocked_by_table_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{foo, bar}, read]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

lock_read_cleanup_when_blocked_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{foo, baz}, read]}, [], State1),
    {State3, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{foo, baq}, write]}, [], State2),
    %% Locks aquired
    #state{read_locks = RLocks, write_locks = WLocks} = State3,
    ExpectedR = #{{foo, baz} => [Tid]},
    ExpectedW = #{{foo, baq} => Tid},
    ExpectedR = RLocks,
    ExpectedW = WLocks,

    {State4, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{foo, bar}, write]}, [], State3),
    {State5, _, {error, locked}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{foo, bar}, read]}, [], State4),
    %% Read locks are empty
    #state{read_locks = RLocks1,
           write_locks = WLocks1,
           transaction_locks = TLGraph} = State5,
    ExpectedR1 = #{},
    ExpectedW1 = #{{foo, bar} => Tid1},
    ExpectedR1 = RLocks1,
    ExpectedW1 = WLocks1,

    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

lock_write_blocked_by_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{foo, bar}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{foo, bar}, write]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

lock_write_blocked_by_table_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{foo, bar}, write]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

lock_write_blocked_by_read_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{foo, bar}, read]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{foo, bar}, write]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

lock_write_blocked_by_table_read_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, read]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {lock, Tid, Source, [{foo, bar}, write]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

% read:
%     fail if no transaction
%     attempt lock
%     return read data

read_no_transaction_error_test() ->
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {read, Tid, Source, [table, foo, read]}, [], InitState).

read_wrong_transaction_error_test() ->
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {read, Tid, Source, [table, foo, read]}, [], InitState).

read_locked_by_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{foo, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {read, Tid, Source, [foo, foo, read]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

read_with_write_lock_locked_by_read_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{foo, foo}, read]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {read, Tid, Source, [foo, foo, write]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

read_returns_and_aquires_lock_test() ->
    mnesia:start(),
    mnesia:delete_table(foo),
    mnesia:create_table(foo, []),
    mnesia:dirty_write({foo, foo, val}),
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks}, _, {ok, [{foo, foo, val}]}} =
        ramnesia_machine:apply(none, {read, Tid, Source, [foo, foo, read]}, [], State),
    ExpectedR = #{{foo, foo} => [Tid]},
    ExpectedR = RLocks.

% index_read/match_object/index_match_object/all_keys:
%     fail if no transaction
%     attempt lock table
%     return read data

%% Index read

index_read_no_transaction_error_test() ->
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {index_read, Tid, Source, [foo, foo, 1, read]}, [], InitState).

index_read_wrong_transaction_error_test() ->
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {index_read, Tid, Source, [foo, foo, 1, read]}, [], InitState).

index_read_locked_by_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {index_read, Tid, Source, [foo, foo, 1, read]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

index_read_returns_and_aquires_lock_test() ->
    mnesia:start(),
    mnesia:delete_table(foo),
    mnesia:create_table(foo, []),
    mnesia:add_table_index(foo, val),
    mnesia:dirty_write({foo, foo, val}),
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks}, _, {ok, [{foo, foo, val}]}} =
        ramnesia_machine:apply(none, {index_read, Tid, Source, [foo, val, 3, read]}, [], State),
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedR = RLocks.

%% Match object

match_object_no_transaction_error_test() ->
    Pattern = {foo, '_', val},
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {match_object, Tid, Source, [foo, Pattern, read]}, [], InitState).

match_object_wrong_transaction_error_test() ->
    Pattern = {foo, '_', val},
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {match_object, Tid, Source, [foo, Pattern, read]}, [], InitState).

match_object_locked_by_write_test() ->
    Pattern = {foo, '_', val},
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {match_object, Tid, Source, [foo, Pattern, read]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

match_object_returns_and_aquires_lock_test() ->
    Pattern = {foo, '_', val},
    mnesia:start(),
    mnesia:delete_table(foo),
    mnesia:create_table(foo, []),
    mnesia:dirty_write({foo, foo, val}),
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks}, _, {ok, [{foo, foo, val}]}} =
        ramnesia_machine:apply(none, {match_object, Tid, Source, [foo, Pattern, read]}, [], State),
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedR = RLocks.

%% Index match object

index_match_object_no_transaction_error_test() ->
    Pattern = {foo, '_', val},
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {index_match_object, Tid, Source, [foo, Pattern, 3, read]}, [], InitState).

index_match_object_wrong_transaction_error_test() ->
    Pattern = {foo, '_', val},
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {index_match_object, Tid, Source, [foo, Pattern, 3, read]}, [], InitState).

index_match_object_locked_by_write_test() ->
    Pattern = {foo, '_', val},
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {index_match_object, Tid, Source, [foo, Pattern, 3, read]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

index_match_object_returns_and_aquires_lock_test() ->
    Pattern = {foo, '_', val},
    mnesia:start(),
    mnesia:delete_table(foo),
    mnesia:create_table(foo, []),
    mnesia:add_table_index(foo, val),
    mnesia:dirty_write({foo, foo, val}),
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks}, _, {ok, [{foo, foo, val}]}} =
        ramnesia_machine:apply(none, {index_match_object, Tid, Source, [foo, Pattern, 3, read]}, [], State),
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedR = RLocks.

%% All keys

all_keys_no_transaction_error_test() ->
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {all_keys, Tid, Source, [foo, read]}, [], InitState).

all_keys_wrong_transaction_error_test() ->
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {all_keys, Tid, Source, [foo, read]}, [], InitState).

all_keys_locked_by_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {all_keys, Tid, Source, [foo, read]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

all_keys_returns_and_aquires_lock_test() ->
    mnesia:start(),
    mnesia:delete_table(foo),
    mnesia:create_table(foo, []),
    mnesia:dirty_write({foo, foo, val}),
    mnesia:dirty_write({foo, bar, val1}),
    mnesia:dirty_write({foo, baz, val2}),
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks}, _, {ok, Keys}} =
        ramnesia_machine:apply(none, {all_keys, Tid, Source, [foo, read]}, [], State),
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedR = RLocks,
    Expected = lists:usort([foo, bar, baz]),
    Expected = lists:usort(Keys).

% first/last/next/prev:
%     fail if no transaction
%     attempt lock table with read lock
%     return read data

%% First

first_no_transaction_error_test() ->
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {first, Tid, Source, [foo]}, [], InitState).

first_wrong_transaction_error_test() ->
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {first, Tid, Source, [foo]}, [], InitState).

first_locked_by_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {first, Tid, Source, [foo]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

first_returns_and_aquires_lock_test() ->
    mnesia:start(),
    mnesia:delete_table(foo),
    mnesia:create_table(foo, []),
    mnesia:dirty_write({foo, bar, val}),
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks}, _, {ok, bar}} =
        ramnesia_machine:apply(none, {first, Tid, Source, [foo]}, [], State),
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedR = RLocks.

%% Last

last_no_transaction_error_test() ->
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {last, Tid, Source, [foo]}, [], InitState).

last_wrong_transaction_error_test() ->
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {last, Tid, Source, [foo]}, [], InitState).

last_locked_by_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {last, Tid, Source, [foo]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

last_returns_and_aquires_lock_test() ->
    mnesia:start(),
    mnesia:delete_table(foo),
    mnesia:create_table(foo, []),
    mnesia:dirty_write({foo, bar, val}),
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks}, _, {ok, bar}} =
        ramnesia_machine:apply(none, {last, Tid, Source, [foo]}, [], State),
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedR = RLocks.

%% Prev

prev_no_transaction_error_test() ->
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {prev, Tid, Source, [foo, bar]}, [], InitState).

prev_wrong_transaction_error_test() ->
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {prev, Tid, Source, [foo, bar]}, [], InitState).

prev_locked_by_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {prev, Tid, Source, [foo, bar]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

prev_returns_and_aquires_lock_test() ->
    mnesia:start(),
    mnesia:delete_table(foo),
    mnesia:create_table(foo, []),
    mnesia:dirty_write({foo, baz, val}),
    mnesia:dirty_write({foo, bar, val}),
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks}, _, {ok, baz}} =
        ramnesia_machine:apply(none, {prev, Tid, Source, [foo, bar]}, [], State),
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedR = RLocks.

%% Next

next_no_transaction_error_test() ->
    InitState = #state{},
    Source = self(),
    Tid = 1,
    {InitState, [], {error, no_transaction_for_pid}} =
        ramnesia_machine:apply(none, {next, Tid, Source, [foo, bar]}, [], InitState).

next_wrong_transaction_error_test() ->
    Source = self(),
    Tid = 2,
    DifferentTid = 1,
    InitState = #state{transactions = #{Source => DifferentTid}, last_transaction_id = DifferentTid},
    {InitState, [], {error, {wrong_transaction_id, DifferentTid}}} =
        ramnesia_machine:apply(none, {next, Tid, Source, [foo, bar]}, [], InitState).

next_locked_by_write_test() ->
    InitState = #state{},
    Source = self(),
    Source1 = spawn(fun() -> ok end),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, _, {ok, Tid1}} =
        ramnesia_machine:apply(none, {start_transaction, Source1}, [], State),
    {State2, _, {ok, ok}} =
        ramnesia_machine:apply(none, {lock, Tid1, Source1, [{table, foo}, write]}, [], State1),
    {State3, _, {error, locked}} =
        ramnesia_machine:apply(none, {next, Tid, Source, [foo, bar]}, [], State2),
    TLGraph = State3#state.transaction_locks,
    [{Tid1, Tid}] = simple_dgraph:out_edges(TLGraph, Tid1),
    [{Tid1, Tid}] = simple_dgraph:in_edges(TLGraph, Tid).

next_returns_and_aquires_lock_test() ->
    mnesia:start(),
    mnesia:delete_table(foo),
    mnesia:create_table(foo, []),
    mnesia:dirty_write({foo, baz, val}),
    mnesia:dirty_write({foo, bar, val}),
    InitState = #state{},
    Source = self(),
    {State, _, {ok, Tid}} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {#state{read_locks = RLocks}, _, {ok, baz}} =
        ramnesia_machine:apply(none, {next, Tid, Source, [foo, bar]}, [], State),
    ExpectedR = #{{table, foo} => [Tid]},
    ExpectedR = RLocks.

% DOWN from a moniror:
%     rollback a transaction for the pid

down_no_transaction_test() ->
    InitState = #state{},
    Source = self(),
    %% The return value is ignored
    {InitState, [], _} =
        ramnesia_machine:apply(none, {down, Source, reason}, [], InitState).

down_cleanup_test() ->
    Source = self(),
    InitState = #state{},
    {State = #state{last_transaction_id = LastTid}, [{monitor, process, Source}], _} =
        ramnesia_machine:apply(none, {start_transaction, Source}, [], InitState),
    {State1, [{demonitor, process, Source}], _} =
        ramnesia_machine:apply(none, {down, Source, reason}, [], State),
    Expected = #state{last_transaction_id = LastTid},
    Expected = State1.

down_cleanup_locks_test() ->
    Source = self(),
    Tid = 1,
    Source1 = spawn(fun() -> ok end),
    Tid1 = 2,
    Source2 = spawn(fun() -> ok end),
    Tid2 = 3,
    LastTid = 3,
    InitState = #state{transactions = #{Source => Tid,
                                        Source1 => Tid1,
                                        Source2 => Tid2},
                       last_transaction_id = LastTid,
                       write_locks = #{writelock => Tid,
                                       writelock_1 => Tid1},
                       read_locks = #{readlock => [Tid],
                                      readlock_1 => [Tid, Tid1],
                                      readlock_2 => [Tid2]}},
    {State1, [{demonitor, process, Source}], _} =
        ramnesia_machine:apply(none, {down, Source, reason}, [], InitState),
    Expected = #state{last_transaction_id = LastTid,
                      transactions = #{Source1 => Tid1, Source2 => Tid2},
                      write_locks = #{writelock_1 => Tid1},
                      read_locks = #{readlock_1 => [Tid1], readlock_2 => [Tid2]}},
    Expected = State1,
    {State2, [{demonitor, process, Source1}], _} =
        ramnesia_machine:apply(none, {down, Source1, reason}, [], State1),
    {State3, [{demonitor, process, Source2}], _} =
        ramnesia_machine:apply(none, {down, Source2, reason}, [], State2),
    State3 = #state{last_transaction_id = LastTid}.

-endif.
